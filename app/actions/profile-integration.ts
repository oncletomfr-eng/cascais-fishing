'use server'

import { auth } from '@/auth'
import { BadgeCategory, FishingExperience } from '@prisma/client'
import { revalidatePath } from 'next/cache'
import { awardBadgesBasedOnActivity } from '@/app/api/badges/route'
import prisma from '@/lib/prisma'

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ –∏–ª–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è —Ä—ã–±–æ–ª–æ–≤–∞
 */
export async function createOrUpdateFisherProfile(formData: {
  experience: string
  bio?: string
  specialties?: string[]
}) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Unauthorized')
  }

  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø—Ä–æ—Ñ–∏–ª—å
    const existingProfile = await prisma.fisherProfile.findUnique({
      where: { userId: session.user.id }
    })

    let profile
    
    if (existingProfile) {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π –ø—Ä–æ—Ñ–∏–ª—å
      profile = await prisma.fisherProfile.update({
        where: { userId: session.user.id },
        data: {
          experience: formData.experience as FishingExperience,
          bio: formData.bio || '',
          specialties: formData.specialties || [],
          lastActiveAt: new Date()
        }
      })
    } else {
      // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π –ø—Ä–æ—Ñ–∏–ª—å
      profile = await prisma.fisherProfile.create({
        data: {
          userId: session.user.id,
          experience: formData.experience as any,
          bio: formData.bio || '',
          specialties: formData.specialties || [],
          rating: 5.0,
          completedTrips: 0,
          totalReviews: 0,
          reliability: 100,
          isActive: true,
          lastActiveAt: new Date()
        }
      })

      // –ù–∞–≥—Ä–∞–∂–¥–∞–µ–º –Ω–æ–≤–∏—á–∫–∞ –∑–∞ —Å–æ–∑–¥–∞–Ω–∏–µ –ø—Ä–æ—Ñ–∏–ª—è
      await prisma.fisherBadge.create({
        data: {
          profileId: profile.id,
          name: 'Welcome Aboard',
          description: '–°–æ–∑–¥–∞–ª –ø—Ä–æ—Ñ–∏–ª—å —Ä—ã–±–æ–ª–æ–≤–∞',
          icon: 'üé£',
          category: BadgeCategory.MILESTONE
        }
      })
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º badges –Ω–∞ –æ—Å–Ω–æ–≤–µ –Ω–æ–≤–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏
    await awardBadgesBasedOnActivity(session.user.id)

    revalidatePath('/profiles')
    return { success: true, profile }

  } catch (error) {
    console.error('Error creating/updating profile:', error)
    throw new Error('Failed to create or update profile')
  }
}

/**
 * –ü–æ–¥–∞—á–∞ –∑–∞—è–≤–∫–∏ –Ω–∞ —É—á–∞—Å—Ç–∏–µ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π –ø–æ–µ–∑–¥–∫–µ
 */
export async function submitParticipantApplication(
  tripId: string,
  message?: string
) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Unauthorized')
  }

  try {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–µ–∑–¥–∫–∞
    const trip = await prisma.groupTrip.findUnique({
      where: { id: tripId },
      include: {
        bookings: {
          where: { status: 'CONFIRMED' },
          select: { participants: true, userId: true }
        },
        participantApprovals: {
          where: { participantId: session.user.id },
          select: { id: true, status: true }
        }
      }
    })

    if (!trip) {
      throw new Error('Trip not found')
    }

    if (trip.status !== 'FORMING') {
      throw new Error('Trip is not accepting new participants')
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—á–∞—Å—Ç–Ω–∏–∫ –µ—â–µ –Ω–µ –ø–æ–¥–∞–≤–∞–ª –∑–∞—è–≤–∫—É
    const existingApproval = trip.participantApprovals.find(
      approval => approval.status === 'PENDING' || approval.status === 'APPROVED'
    )

    if (existingApproval) {
      throw new Error(
        existingApproval.status === 'PENDING' 
          ? 'Application already pending' 
          : 'Already approved for this trip'
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—á–∞—Å—Ç–Ω–∏–∫ —É–∂–µ –Ω–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω –Ω–∞–ø—Ä—è–º—É—é
    const existingBooking = trip.bookings.find(booking => booking.userId === session.user.id)
    if (existingBooking) {
      throw new Error('Already booked for this trip')
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –µ—Å—Ç—å –º–µ—Å—Ç–∞
    const currentParticipants = trip.bookings.reduce(
      (sum, booking) => sum + booking.participants, 
      0
    )

    if (currentParticipants >= trip.maxParticipants) {
      throw new Error('Trip is full')
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞—è–≤–∫—É –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ
    const approval = await prisma.participantApproval.create({
      data: {
        tripId,
        participantId: session.user.id,
        message: message || null,
        status: 'PENDING'
      },
      include: {
        participant: {
          select: {
            name: true,
            email: true
          }
        },
        trip: {
          select: {
            date: true,
            timeSlot: true,
            captain: {
              select: { name: true }
            }
          }
        }
      }
    })

    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø—Ä–æ—Ñ–∏–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await prisma.fisherProfile.updateMany({
      where: { userId: session.user.id },
      data: { lastActiveAt: new Date() }
    })

    // –ù–∞–≥—Ä–∞–∂–¥–∞–µ–º badges –∑–∞ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
    await awardBadgesBasedOnActivity(session.user.id)

    revalidatePath(`/trip/${tripId}`)
    revalidatePath('/admin/trips')

    return { success: true, approval }

  } catch (error) {
    console.error('Error submitting application:', error)
    throw new Error(error instanceof Error ? error.message : 'Failed to submit application')
  }
}

/**
 * –ü—Ä—è–º–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–ª—è –æ–ø—ã—Ç–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
 */
export async function createDirectBooking(
  tripId: string,
  participants: number = 1
) {
  const session = await auth()
  if (!session?.user) {
    throw new Error('Unauthorized')
  }

  try {
    // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –ø—Ä–∞–≤–∞ –Ω–∞ –ø—Ä—è–º–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
    const profile = await prisma.fisherProfile.findUnique({
      where: { userId: session.user.id }
    })

    if (!profile) {
      throw new Error('Profile required for booking')
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –º–æ–∂–µ—Ç –ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –Ω–∞–ø—Ä—è–º—É—é
    const canBookDirectly = 
      profile.completedTrips >= 3 && 
      profile.reliability >= 85 && 
      profile.isActive &&
      (profile.totalReviews === 0 || profile.rating >= 4.0)

    if (!canBookDirectly) {
      throw new Error('Direct booking not allowed - approval required')
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ–µ–∑–¥–∫—É
    const trip = await prisma.groupTrip.findUnique({
      where: { id: tripId },
      include: {
        bookings: {
          where: { status: 'CONFIRMED' },
          select: { participants: true }
        }
      }
    })

    if (!trip) {
      throw new Error('Trip not found')
    }

    if (trip.status !== 'FORMING') {
      throw new Error('Trip is not accepting bookings')
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å –º–µ—Å—Ç
    const currentParticipants = trip.bookings.reduce(
      (sum, booking) => sum + booking.participants, 
      0
    )

    if (currentParticipants + participants > trip.maxParticipants) {
      throw new Error('Not enough spots available')
    }

    // –°–æ–∑–¥–∞–µ–º –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
    const booking = await prisma.groupBooking.create({
      data: {
        tripId,
        userId: session.user.id,
        participants,
        totalPrice: trip.pricePerPerson * participants,
        contactName: session.user.name || '',
        contactPhone: '', // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ø–æ–ª–µ –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–∞
        contactEmail: session.user.email || '',
        status: 'CONFIRMED'
      }
    })

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –ø–æ–µ–∑–¥–∫–∏ –µ—Å–ª–∏ –Ω–∞–±—Ä–∞–Ω –º–∏–Ω–∏–º—É–º
    const newTotalParticipants = currentParticipants + participants
    if (newTotalParticipants >= trip.minRequired && trip.status === 'FORMING') {
      await prisma.groupTrip.update({
        where: { id: tripId },
        data: { status: 'CONFIRMED' }
      })
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–æ—Ñ–∏–ª—è
    await prisma.fisherProfile.update({
      where: { userId: session.user.id },
      data: {
        lastActiveAt: new Date(),
        // –ú–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å —Å—á–µ—Ç—á–∏–∫ –ø–ª–∞–Ω–∏—Ä—É–µ–º—ã—Ö –ø–æ–µ–∑–¥–æ–∫
      }
    })

    // –ù–∞–≥—Ä–∞–∂–¥–∞–µ–º badges
    await awardBadgesBasedOnActivity(session.user.id)

    revalidatePath(`/trip/${tripId}`)
    revalidatePath('/bookings')

    return { success: true, booking }

  } catch (error) {
    console.error('Error creating direct booking:', error)
    throw new Error(error instanceof Error ? error.message : 'Failed to create booking')
  }
}

/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–ø—É—Ç–∞—Ü–∏–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –ø–æ—Å–ª–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –ø–æ–µ–∑–¥–∫–∏
 */
export async function updateUserReputationAfterTrip(
  userId: string,
  tripResult: 'COMPLETED' | 'CANCELLED' | 'NO_SHOW',
  additionalData?: {
    wasOnTime?: boolean
    hadEquipment?: boolean
    followedRules?: boolean
  }
) {
  try {
    const profile = await prisma.fisherProfile.findUnique({
      where: { userId }
    })

    if (!profile) {
      throw new Error('Profile not found')
    }

    let reliabilityChange = 0
    let completedTripsChange = 0

    switch (tripResult) {
      case 'COMPLETED':
        reliabilityChange = Math.min(2, 100 - Number(profile.reliability))
        completedTripsChange = 1
        
        // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –±–æ–Ω—É—Å—ã –∑–∞ —Ö–æ—Ä–æ—à–µ–µ –ø–æ–≤–µ–¥–µ–Ω–∏–µ
        if (additionalData?.wasOnTime) reliabilityChange += 1
        if (additionalData?.hadEquipment) reliabilityChange += 1
        if (additionalData?.followedRules) reliabilityChange += 1
        break
        
      case 'CANCELLED':
        // –ù–µ–π—Ç—Ä–∞–ª—å–Ω–æ–µ –≤–ª–∏—è–Ω–∏–µ - –ø–æ–µ–∑–¥–∫–∞ –æ—Ç–º–µ–Ω–∏–ª–∞—Å—å –Ω–µ –ø–æ –≤–∏–Ω–µ —É—á–∞—Å—Ç–Ω–∏–∫–∞
        break
        
      case 'NO_SHOW':
        reliabilityChange = -Math.min(10, Number(profile.reliability))
        break
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
    await prisma.fisherProfile.update({
      where: { userId },
      data: {
        reliability: Math.max(0, Math.min(100, Number(profile.reliability) + reliabilityChange)),
        completedTrips: profile.completedTrips + completedTripsChange,
        lastActiveAt: new Date()
      }
    })

    // –û–±–Ω–æ–≤–ª—è–µ–º badges
    if (tripResult === 'COMPLETED') {
      await awardBadgesBasedOnActivity(userId)
    }

    console.log(`Updated reputation for ${userId}: reliability ${reliabilityChange > 0 ? '+' : ''}${reliabilityChange}`)

    return { success: true }

  } catch (error) {
    console.error('Error updating reputation:', error)
    throw new Error('Failed to update reputation')
  }
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–π –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ –æ—Å–Ω–æ–≤–µ –ø—Ä–æ—Ñ–∏–ª—è
 */
export async function getUserRecommendations(userId: string) {
  try {
    const profile = await prisma.fisherProfile.findUnique({
      where: { userId },
      include: {
        user: {
          include: {
            groupBookings: {
              where: { status: 'CONFIRMED' },
              include: {
                trip: {
                  select: {
                    date: true,
                    timeSlot: true,
                    description: true
                  }
                }
              },
              orderBy: { createdAt: 'desc' },
              take: 5
            }
          }
        }
      }
    })

    if (!profile) {
      return { recommendations: [], reasons: [] }
    }

    const recommendations = []
    const reasons = []

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –æ–ø—ã—Ç–∞
    if (profile.experience === 'BEGINNER') {
      recommendations.push('–ü–æ–ø—Ä–æ–±—É–π—Ç–µ —É—Ç—Ä–µ–Ω–Ω–∏–µ –ø–æ–µ–∑–¥–∫–∏ - –æ–Ω–∏ –æ–±—ã—á–Ω–æ –±–æ–ª–µ–µ —Å–ø–æ–∫–æ–π–Ω—ã–µ')
      reasons.push('–û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –≤–∞—à–µ–º —É—Ä–æ–≤–Ω–µ –æ–ø—ã—Ç–∞: –ù–æ–≤–∏—á–æ–∫')
    }

    if (profile.experience === 'EXPERT') {
      recommendations.push('–†–∞—Å—Å–º–æ—Ç—Ä–∏—Ç–µ –ø–æ–µ–∑–¥–∫–∏ –≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –º–æ—Ä–µ –¥–ª—è –ª—É—á—à–µ–≥–æ —É–ª–æ–≤–∞')
      reasons.push('–û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –≤–∞—à–µ–º —ç–∫—Å–ø–µ—Ä—Ç–Ω–æ–º —É—Ä–æ–≤–Ω–µ')
    }

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏
    if (profile.completedTrips >= 5) {
      recommendations.push('–ü–æ–ø—Ä–æ–±—É–π—Ç–µ –Ω–æ–≤—ã–µ –º–µ—Å—Ç–∞ –¥–ª—è —Ä—ã–±–∞–ª–∫–∏')
      reasons.push(`–£ –≤–∞—Å —É–∂–µ ${profile.completedTrips} –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –ø–æ–µ–∑–¥–æ–∫`)
    }

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–π
    if (profile.specialties.includes('–°–ø–∏–Ω–Ω–∏–Ω–≥')) {
      recommendations.push('–ò—â–∏—Ç–µ –ø–æ–µ–∑–¥–∫–∏ —Å —Ñ–æ–∫—É—Å–æ–º –Ω–∞ —Ö–∏—â–Ω—É—é —Ä—ã–±—É')
      reasons.push('–û—Å–Ω–æ–≤–∞–Ω–æ –Ω–∞ –≤–∞—à–µ–π —Å–ø–µ—Ü–∏–∞–ª–∏–∑–∞—Ü–∏–∏: –°–ø–∏–Ω–Ω–∏–Ω–≥')
    }

    // –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏ –Ω–∞ –æ—Å–Ω–æ–≤–µ —Å–µ–∑–æ–Ω–∞
    const month = new Date().getMonth()
    if (month >= 11 || month <= 1) { // –ó–∏–º–∞
      recommendations.push('–ó–∏–º–Ω–∏–µ –ø–æ–µ–∑–¥–∫–∏ –æ—Ç–ª–∏—á–Ω–æ –ø–æ–¥—Ö–æ–¥—è—Ç –¥–ª—è –º–æ—Ä—Å–∫–æ–π —Ä—ã–±–∞–ª–∫–∏')
      reasons.push('–°–µ–∑–æ–Ω–Ω–∞—è —Ä–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏—è –¥–ª—è –∑–∏–º–Ω–µ–≥–æ –ø–µ—Ä–∏–æ–¥–∞')
    }

    return { recommendations, reasons }

  } catch (error) {
    console.error('Error getting recommendations:', error)
    return { recommendations: [], reasons: [] }
  }
}

/**
 * –°–æ–∑–¥–∞–Ω–∏–µ custom badge –¥–ª—è –æ—Å–æ–±—ã—Ö –¥–æ—Å—Ç–∏–∂–µ–Ω–∏–π
 */
export async function awardCustomBadge(
  userId: string,
  badgeData: {
    name: string
    description: string
    icon: string
    category: 'ACHIEVEMENT' | 'MILESTONE' | 'SPECIAL' | 'SEASONAL'
  }
) {
  const session = await auth()
  if (!session?.user || session.user.role !== 'ADMIN') {
    throw new Error('Admin access required')
  }

  try {
    const profile = await prisma.fisherProfile.findUnique({
      where: { userId }
    })

    if (!profile) {
      throw new Error('Profile not found')
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —Ç–∞–∫–æ–π badge –µ—â–µ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    const existingBadge = await prisma.fisherBadge.findFirst({
      where: {
        profileId: profile.id,
        name: badgeData.name
      }
    })

    if (existingBadge) {
      throw new Error('Badge already exists')
    }

    const badge = await prisma.fisherBadge.create({
      data: {
        profileId: profile.id,
        name: badgeData.name,
        description: badgeData.description,
        icon: badgeData.icon,
        category: badgeData.category as BadgeCategory
      }
    })

    return { success: true, badge }

  } catch (error) {
    console.error('Error awarding custom badge:', error)
    throw new Error(error instanceof Error ? error.message : 'Failed to award badge')
  }
}
