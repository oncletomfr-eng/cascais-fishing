import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/auth'
import { PrismaClient } from '@prisma/client'
import { z } from 'zod'
// TEMPORARILY DISABLED: badges excluded from deployment to solve 250MB limit
// import { awardBadgesBasedOnActivity } from '@/app/api/badges/route'

const prisma = new PrismaClient()

// Schema –¥–ª—è –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏
const analyticsParamsSchema = z.object({
  userId: z.string().cuid().optional(),
  period: z.enum(['week', 'month', 'quarter', 'year', 'all']).default('month'),
  includeComparisons: z.boolean().default(true),
  includePredictions: z.boolean().default(false)
})

/**
 * GET /api/profiles/analytics - –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø—Ä–æ—Ñ–∏–ª–µ–π
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    console.log('üìä Fetching profile analytics:', Object.fromEntries(searchParams))

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
    const session = await auth()
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // –ü–∞—Ä—Å–∏–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
    const params = {
      userId: searchParams.get('userId') || undefined,
      period: searchParams.get('period') || 'month',
      includeComparisons: searchParams.get('includeComparisons') === 'true',
      includePredictions: searchParams.get('includePredictions') === 'true'
    }

    const validationResult = analyticsParamsSchema.safeParse(params)
    if (!validationResult.success) {
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid parameters', 
          details: validationResult.error.flatten() 
        },
        { status: 400 }
      )
    }

    const { userId, period, includeComparisons, includePredictions } = validationResult.data

    // –ï—Å–ª–∏ –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ—Ç—Å—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    if (userId) {
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
      const canAccess = session.user.id === userId || session.user.role === 'ADMIN'
      if (!canAccess) {
        return NextResponse.json(
          { success: false, error: 'Access denied' },
          { status: 403 }
        )
      }

      const analytics = await getUserAnalytics(userId, period, includeComparisons, includePredictions)
      return NextResponse.json({
        success: true,
        data: analytics
      })
    }

    // –û–±—â–∞—è –∞–Ω–∞–ª–∏—Ç–∏–∫–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –∞–¥–º–∏–Ω–æ–≤)
    if (session.user.role !== 'ADMIN') {
      return NextResponse.json(
        { success: false, error: 'Admin access required for general analytics' },
        { status: 403 }
      )
    }

    const generalAnalytics = await getGeneralAnalytics(period, includeComparisons)
    return NextResponse.json({
      success: true,
      data: generalAnalytics
    })

  } catch (error) {
    console.error('‚ùå Error fetching analytics:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

/**
 * POST /api/profiles/analytics - –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –∏ –ø–µ—Ä–µ—Å—á–µ—Ç badges
 */
export async function POST(request: NextRequest) {
  try {
    console.log('üîÑ Triggering analytics update')

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
    const session = await auth()
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const body = await request.json()
    const { userId, updateBadges = true } = body

    const targetUserId = userId || session.user.id

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –¥–æ—Å—Ç—É–ø–∞
    const canUpdate = session.user.id === targetUserId || session.user.role === 'ADMIN'
    if (!canUpdate) {
      return NextResponse.json(
        { success: false, error: 'Access denied' },
        { status: 403 }
      )
    }

    console.log('üéØ Updating analytics for user:', targetUserId)

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –ø—Ä–æ—Ñ–∏–ª—è
    const updatedProfile = await updateUserStatistics(targetUserId)
    if (!updatedProfile) {
      return NextResponse.json(
        { success: false, error: 'Profile not found' },
        { status: 404 }
      )
    }

    // TEMPORARILY DISABLED: badges excluded from deployment to solve 250MB limit
    let newBadges: any[] = []
    if (updateBadges) {
      // newBadges = await awardBadgesBasedOnActivity(targetUserId)
      console.log('‚ö†Ô∏è Badge awarding disabled - badges API excluded from deployment')
    }

    // –ü–æ–ª—É—á–∞–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—É—é –∞–Ω–∞–ª–∏—Ç–∏–∫—É
    const analytics = await getUserAnalytics(targetUserId, 'month', true, false)

    return NextResponse.json({
      success: true,
      data: {
        profile: updatedProfile,
        newBadges,
        analytics
      },
      message: `Analytics updated. ${newBadges.length} new badges awarded.`
    })

  } catch (error) {
    console.error('‚ùå Error updating analytics:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–µ—Ç–∞–ª—å–Ω–æ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
async function getUserAnalytics(
  userId: string, 
  period: string, 
  includeComparisons: boolean,
  includePredictions: boolean
) {
  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –≤—Ä–µ–º–µ–Ω–Ω–æ–π –¥–∏–∞–ø–∞–∑–æ–Ω
  const now = new Date()
  const periodStart = getPeriodStart(period, now)

  // –û—Å–Ω–æ–≤–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø—Ä–æ—Ñ–∏–ª–µ
  const profile = await prisma.fisherProfile.findUnique({
    where: { userId },
    include: {
      user: {
        include: {
          groupBookings: {
            where: {
              status: 'CONFIRMED',
              createdAt: { gte: periodStart }
            },
            include: {
              trip: {
                select: {
                  date: true,
                  timeSlot: true,
                  status: true
                }
              }
            }
          },
          reviewsReceived: {
            where: {
              verified: true,
              createdAt: { gte: periodStart }
            },
            select: {
              rating: true,
              comment: true,
              createdAt: true,
              fromUser: {
                select: { name: true }
              }
            }
          },
          reviewsGiven: {
            where: { createdAt: { gte: periodStart } },
            select: {
              rating: true,
              createdAt: true
            }
          },
          participantApprovals: {
            where: { appliedAt: { gte: periodStart } },
            select: {
              status: true,
              appliedAt: true,
              processedAt: true,
              trip: {
                select: {
                  date: true,
                  captain: {
                    select: { name: true }
                  }
                }
              }
            }
          }
        }
      },
      badges: {
        where: { earnedAt: { gte: periodStart } },
        orderBy: { earnedAt: 'desc' }
      }
    }
  })

  if (!profile) return null

  // –ë–∞–∑–æ–≤—ã–µ –º–µ—Ç—Ä–∏–∫–∏
  const metrics = {
    bookings: {
      total: profile.user.groupBookings.length,
      completed: profile.user.groupBookings.filter(b => 
        b.trip.status === 'COMPLETED'
      ).length,
      cancelled: profile.user.groupBookings.filter(b => 
        b.trip.status === 'CANCELLED'
      ).length
    },
    reviews: {
      received: profile.user.reviewsReceived.length,
      given: profile.user.reviewsGiven.length,
      averageRating: profile.user.reviewsReceived.length > 0
        ? profile.user.reviewsReceived.reduce((sum, r) => sum + r.rating, 0) / profile.user.reviewsReceived.length
        : 0
    },
    approvals: {
      applied: profile.user.participantApprovals.length,
      approved: profile.user.participantApprovals.filter(a => a.status === 'APPROVED').length,
      rejected: profile.user.participantApprovals.filter(a => a.status === 'REJECTED').length,
      pending: profile.user.participantApprovals.filter(a => a.status === 'PENDING').length
    },
    badges: {
      earned: profile.badges.length,
      categories: profile.badges.reduce((acc, badge) => {
        acc[badge.category] = (acc[badge.category] || 0) + 1
        return acc
      }, {} as Record<string, number>)
    }
  }

  // –î–∏–Ω–∞–º–∏–∫–∞ –ø–æ –≤—Ä–µ–º–µ–Ω–∏ (–ø–æ–º–µ—Å—è—á–Ω–æ/–ø–æ–Ω–µ–¥–µ–ª—å–Ω–æ)
  const timeSeriesData = await generateTimeSeries(userId, period, periodStart)

  // –°—Ä–∞–≤–Ω–µ–Ω–∏–µ —Å –¥—Ä—É–≥–∏–º–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º–∏ (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
  let comparison = null
  if (includeComparisons) {
    comparison = await getComparisonData(profile, periodStart)
  }

  // –ü—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è (–µ—Å–ª–∏ –≤–∫–ª—é—á–µ–Ω–æ)
  let predictions = null
  if (includePredictions) {
    predictions = await generatePredictions(profile, metrics)
  }

  return {
    profile: {
      id: profile.id,
      experience: profile.experience,
      rating: Number(profile.rating),
      completedTrips: profile.completedTrips,
      reliability: Number(profile.reliability),
      totalReviews: profile.totalReviews,
      isActive: profile.isActive,
      lastActiveAt: profile.lastActiveAt
    },
    metrics,
    timeSeries: timeSeriesData,
    comparison,
    predictions,
    recentActivity: {
      bookings: profile.user.groupBookings.slice(0, 5),
      reviews: profile.user.reviewsReceived.slice(0, 5),
      badges: profile.badges.slice(0, 3)
    }
  }
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –æ–±—â–µ–π –∞–Ω–∞–ª–∏—Ç–∏–∫–∏ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
 */
async function getGeneralAnalytics(period: string, includeComparisons: boolean) {
  const now = new Date()
  const periodStart = getPeriodStart(period, now)

  // –û–±—â–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
  const [
    totalProfiles,
    activeProfiles,
    totalBookings,
    totalReviews,
    totalBadges
  ] = await Promise.all([
    prisma.fisherProfile.count(),
    prisma.fisherProfile.count({
      where: { 
        lastActiveAt: { gte: periodStart },
        isActive: true 
      }
    }),
    prisma.groupBooking.count({
      where: { 
        status: 'CONFIRMED',
        createdAt: { gte: periodStart }
      }
    }),
    prisma.review.count({
      where: { 
        verified: true,
        createdAt: { gte: periodStart }
      }
    }),
    prisma.fisherBadge.count({
      where: { earnedAt: { gte: periodStart } }
    })
  ])

  // –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ —É—Ä–æ–≤–Ω—è–º –æ–ø—ã—Ç–∞
  const experienceDistribution = await prisma.fisherProfile.groupBy({
    by: ['experience'],
    _count: { experience: true },
    where: { isActive: true }
  })

  // –¢–æ–ø –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –ø–æ —Ä–µ–π—Ç–∏–Ω–≥—É
  const topRatedUsers = await prisma.fisherProfile.findMany({
    where: {
      isActive: true,
      totalReviews: { gte: 3 }
    },
    include: {
      user: {
        select: {
          id: true,
          name: true,
          image: true
        }
      }
    },
    orderBy: [
      { rating: 'desc' },
      { totalReviews: 'desc' }
    ],
    take: 10
  })

  // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ badges
  const badgeStats = await prisma.fisherBadge.groupBy({
    by: ['category'],
    _count: { category: true },
    where: { earnedAt: { gte: periodStart } }
  })

  return {
    overview: {
      totalProfiles,
      activeProfiles,
      totalBookings,
      totalReviews,
      totalBadges,
      activityRate: totalProfiles > 0 ? (activeProfiles / totalProfiles * 100) : 0
    },
    distributions: {
      experience: experienceDistribution,
      badges: badgeStats
    },
    topUsers: topRatedUsers.map(profile => ({
      id: profile.user.id,
      name: profile.user.name,
      image: profile.user.image,
      rating: Number(profile.rating),
      completedTrips: profile.completedTrips,
      reliability: Number(profile.reliability)
    }))
  }
}

/**
 * –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
 */
async function updateUserStatistics(userId: string) {
  const profile = await prisma.fisherProfile.findUnique({
    where: { userId },
    include: {
      user: {
        include: {
          groupBookings: {
            where: { status: 'CONFIRMED' },
            select: { id: true }
          },
          reviewsReceived: {
            where: { verified: true },
            select: { rating: true }
          }
        }
      }
    }
  })

  if (!profile) return null

  // –ü–µ—Ä–µ—Å—á–∏—Ç—ã–≤–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É
  const completedTrips = profile.user.groupBookings.length
  const reviews = profile.user.reviewsReceived
  const totalReviews = reviews.length
  const averageRating = totalReviews > 0
    ? reviews.reduce((sum, r) => sum + r.rating, 0) / totalReviews
    : 5.0

  // –û–±–Ω–æ–≤–ª—è–µ–º –ø—Ä–æ—Ñ–∏–ª—å
  const updatedProfile = await prisma.fisherProfile.update({
    where: { userId },
    data: {
      completedTrips,
      totalReviews,
      rating: averageRating,
      lastActiveAt: new Date()
    }
  })

  console.log('üìä Updated statistics for user:', userId, {
    completedTrips,
    totalReviews,
    rating: averageRating
  })

  return updatedProfile
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ä—è–¥–æ–≤ –¥–∞–Ω–Ω—ã—Ö
 */
async function generateTimeSeries(userId: string, period: string, startDate: Date) {
  // –£–ø—Ä–æ—â–µ–Ω–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è - –º–æ–∂–Ω–æ —Ä–∞—Å—à–∏—Ä–∏—Ç—å
  const bookings = await prisma.groupBooking.findMany({
    where: {
      userId,
      status: 'CONFIRMED',
      createdAt: { gte: startDate }
    },
    select: {
      createdAt: true
    },
    orderBy: { createdAt: 'asc' }
  })

  // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ –ø–µ—Ä–∏–æ–¥–∞–º
  const grouped = bookings.reduce((acc, booking) => {
    const key = formatDateForPeriod(booking.createdAt, period)
    acc[key] = (acc[key] || 0) + 1
    return acc
  }, {} as Record<string, number>)

  return Object.entries(grouped).map(([date, count]) => ({
    date,
    bookings: count
  }))
}

/**
 * –ü–æ–ª—É—á–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è —Å—Ä–∞–≤–Ω–µ–Ω–∏—è
 */
async function getComparisonData(profile: any, startDate: Date) {
  // –°—Ä–µ–¥–Ω–∏–µ –ø–æ–∫–∞–∑–∞—Ç–µ–ª–∏ –ø–æ –ø–ª–∞—Ç—Ñ–æ—Ä–º–µ
  const avgStats = await prisma.fisherProfile.aggregate({
    _avg: {
      rating: true,
      completedTrips: true,
      reliability: true
    },
    where: {
      isActive: true,
      totalReviews: { gte: 3 }
    }
  })

  return {
    platform: {
      avgRating: Number(avgStats._avg.rating || 0),
      avgCompletedTrips: Number(avgStats._avg.completedTrips || 0),
      avgReliability: Number(avgStats._avg.reliability || 0)
    },
    user: {
      rating: Number(profile.rating),
      completedTrips: profile.completedTrips,
      reliability: Number(profile.reliability)
    }
  }
}

/**
 * –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏–π (—É–ø—Ä–æ—â–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è)
 */
async function generatePredictions(profile: any, metrics: any) {
  // –ü—Ä–æ—Å—Ç—ã–µ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è –Ω–∞ –æ—Å–Ω–æ–≤–µ —Ç–µ–∫—É—â–∏—Ö —Ç—Ä–µ–Ω–¥–æ–≤
  const bookingTrend = metrics.bookings.total > 0 ? 'growing' : 'stable'
  
  return {
    nextMonthBookings: Math.max(1, Math.round(metrics.bookings.total * 1.2)),
    ratingTrend: profile.rating >= 4.5 ? 'stable' : 'improving',
    recommendedActions: [
      ...(profile.rating < 4.0 ? ['Focus on improving service quality'] : []),
      ...(profile.reliability < 90 ? ['Work on punctuality and reliability'] : []),
      ...(metrics.bookings.total < 3 ? ['Increase booking activity'] : [])
    ]
  }
}

/**
 * –£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –ø–µ—Ä–∏–æ–¥–∞–º–∏
 */
function getPeriodStart(period: string, now: Date): Date {
  switch (period) {
    case 'week':
      return new Date(now.getTime() - 7 * 24 * 60 * 60 * 1000)
    case 'month':
      return new Date(now.getFullYear(), now.getMonth() - 1, now.getDate())
    case 'quarter':
      return new Date(now.getFullYear(), now.getMonth() - 3, now.getDate())
    case 'year':
      return new Date(now.getFullYear() - 1, now.getMonth(), now.getDate())
    case 'all':
      return new Date(2020, 0, 1) // –ù–∞—á–∞–ª–æ –ø—Ä–æ–µ–∫—Ç–∞
    default:
      return new Date(now.getFullYear(), now.getMonth() - 1, now.getDate())
  }
}

function formatDateForPeriod(date: Date, period: string): string {
  switch (period) {
    case 'week':
    case 'month':
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`
    case 'quarter':
    case 'year':
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`
    default:
      return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`
  }
}
