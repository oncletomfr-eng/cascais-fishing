import { NextRequest, NextResponse } from 'next/server'
import { auth } from '@/auth'
import prisma from '@/lib/prisma'
import { ApprovalStatus } from '@prisma/client'
import { z } from 'zod'


// Schema –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è –∑–∞—è–≤–∫–∏ –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ
const createApprovalSchema = z.object({
  tripId: z.string().cuid(),
  message: z.string().optional()
})

// Schema –¥–ª—è —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏ –∑–∞—è–≤–æ–∫
const filterSchema = z.object({
  tripId: z.string().cuid().optional(),
  status: z.enum(['PENDING', 'APPROVED', 'REJECTED']).optional(),
  captainId: z.string().cuid().optional(),
  participantId: z.string().cuid().optional(),
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0)
})

/**
 * POST /api/participant-approvals - –°–æ–∑–¥–∞–Ω–∏–µ –∑–∞—è–≤–∫–∏ –Ω–∞ —É—á–∞—Å—Ç–∏–µ –≤ –≥—Ä—É–ø–ø–æ–≤–æ–π –ø–æ–µ–∑–¥–∫–µ
 */
export async function POST(request: NextRequest) {
  try {
    console.log('üÜï Creating new participant approval request')

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
    const session = await auth()
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    const body = await request.json()
    console.log('üìã Request body:', body)

    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º –¥–∞–Ω–Ω—ã–µ
    const validationResult = createApprovalSchema.safeParse(body)
    if (!validationResult.success) {
      console.error('‚ùå Validation error:', validationResult.error)
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid request data', 
          details: validationResult.error.flatten() 
        },
        { status: 400 }
      )
    }

    const { tripId, message } = validationResult.data

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ–µ–∑–¥–∫–∞
    const trip = await prisma.groupTrip.findUnique({
      where: { id: tripId },
      include: {
        bookings: {
          where: { status: 'CONFIRMED' },
          select: { participants: true, userId: true }
        },
        participantApprovals: {
          where: { participantId: session.user.id },
          select: { id: true, status: true }
        }
      }
    })

    if (!trip) {
      console.error('‚ùå Trip not found:', tripId)
      return NextResponse.json(
        { success: false, error: 'Trip not found' },
        { status: 404 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –ø–æ–µ–∑–¥–∫–∞ –µ—â–µ –Ω–∞–±–∏—Ä–∞–µ—Ç —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    if (trip.status !== 'FORMING') {
      console.error('‚ùå Trip is not forming:', trip.status)
      return NextResponse.json(
        { success: false, error: 'Trip is not accepting new participants' },
        { status: 409 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—á–∞—Å—Ç–Ω–∏–∫ –µ—â–µ –Ω–µ –ø–æ–¥–∞–≤–∞–ª –∑–∞—è–≤–∫—É
    const existingApproval = trip.participantApprovals.find(
      approval => approval.status === 'PENDING' || approval.status === 'APPROVED'
    )

    if (existingApproval) {
      console.error('‚ùå Already applied:', existingApproval.id, existingApproval.status)
      return NextResponse.json(
        { 
          success: false, 
          error: existingApproval.status === 'PENDING' 
            ? 'Application already pending' 
            : 'Already approved for this trip'
        },
        { status: 409 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ —É—á–∞—Å—Ç–Ω–∏–∫ —É–∂–µ –Ω–µ –∑–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω –Ω–∞–ø—Ä—è–º—É—é
    const existingBooking = trip.bookings.find(booking => booking.userId === session.user.id)
    if (existingBooking) {
      console.error('‚ùå Already booked:', session.user.id)
      return NextResponse.json(
        { success: false, error: 'Already booked for this trip' },
        { status: 409 }
      )
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –µ—Å—Ç—å –º–µ—Å—Ç–∞
    const currentParticipants = trip.bookings.reduce(
      (sum, booking) => sum + booking.participants, 
      0
    )

    if (currentParticipants >= trip.maxParticipants) {
      console.error('‚ùå Trip is full:', currentParticipants, '/', trip.maxParticipants)
      return NextResponse.json(
        { success: false, error: 'Trip is full' },
        { status: 409 }
      )
    }

    // –°–æ–∑–¥–∞–µ–º –∑–∞—è–≤–∫—É –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ
    const approval = await prisma.participantApproval.create({
      data: {
        tripId,
        participantId: session.user.id,
        message: message || null,
        status: ApprovalStatus.PENDING
      },
      include: {
        participant: {
          select: {
            id: true,
            name: true,
            email: true,
            image: true,
            fisherProfile: {
              select: {
                experience: true,
                rating: true,
                completedTrips: true,
                reliability: true
              }
            }
          }
        },
        trip: {
          select: {
            id: true,
            date: true,
            timeSlot: true,
            description: true,
            meetingPoint: true,
            captain: {
              select: {
                id: true,
                name: true
              }
            }
          }
        }
      }
    })

    console.log('‚úÖ Approval created:', approval.id)

    // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø—Ä–æ—Ñ–∏–ª—è —É—á–∞—Å—Ç–Ω–∏–∫–∞
    await prisma.fisherProfile.updateMany({
      where: { userId: session.user.id },
      data: { lastActiveAt: new Date() }
    })

    return NextResponse.json({
      success: true,
      data: approval,
      message: 'Application submitted successfully'
    })

  } catch (error) {
    console.error('‚ùå Error creating approval:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}

/**
 * GET /api/participant-approvals - –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∑–∞—è–≤–æ–∫ –Ω–∞ –æ–¥–æ–±—Ä–µ–Ω–∏–µ
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url)
    console.log('üîç Fetching participant approvals with params:', Object.fromEntries(searchParams))

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞—É—Ç–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ü–∏—é
    const session = await auth()
    if (!session?.user) {
      return NextResponse.json(
        { success: false, error: 'Unauthorized' },
        { status: 401 }
      )
    }

    // –ü–∞—Ä—Å–∏–º –∏ –≤–∞–ª–∏–¥–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏–ª—å—Ç—Ä–∞—Ü–∏–∏
    const filterParams = {
      tripId: searchParams.get('tripId') || undefined,
      status: searchParams.get('status') || undefined,
      captainId: searchParams.get('captainId') || undefined,
      participantId: searchParams.get('participantId') || undefined,
      limit: parseInt(searchParams.get('limit') || '20'),
      offset: parseInt(searchParams.get('offset') || '0')
    }

    const validationResult = filterSchema.safeParse(filterParams)
    if (!validationResult.success) {
      console.error('‚ùå Filter validation error:', validationResult.error)
      return NextResponse.json(
        { 
          success: false, 
          error: 'Invalid filter parameters', 
          details: validationResult.error.flatten() 
        },
        { status: 400 }
      )
    }

    const filters = validationResult.data

    // –°—Ç—Ä–æ–∏–º WHERE —É—Å–ª–æ–≤–∏–µ –¥–ª—è –∑–∞–ø—Ä–æ—Å–∞
    const whereCondition: any = {}

    if (filters.tripId) {
      whereCondition.tripId = filters.tripId
    }

    if (filters.status) {
      whereCondition.status = filters.status as ApprovalStatus
    }

    if (filters.participantId) {
      whereCondition.participantId = filters.participantId
    }

    if (filters.captainId) {
      whereCondition.trip = {
        captainId: filters.captainId
      }
    }

    // –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –∞–¥–º–∏–Ω, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –µ–≥–æ –¥–∞–Ω–Ω—ã–µ
    if (session.user.role !== 'ADMIN') {
      // –ö–∞–ø–∏—Ç–∞–Ω –≤–∏–¥–∏—Ç –∑–∞—è–≤–∫–∏ –Ω–∞ —Å–≤–æ–∏ –ø–æ–µ–∑–¥–∫–∏
      // –£—á–∞—Å—Ç–Ω–∏–∫ –≤–∏–¥–∏—Ç —Å–≤–æ–∏ –∑–∞—è–≤–∫–∏
      whereCondition.OR = [
        { participantId: session.user.id },
        { trip: { captainId: session.user.id } }
      ]
    }

    console.log('üîç Where condition:', JSON.stringify(whereCondition, null, 2))

    // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å
    const [approvals, totalCount] = await Promise.all([
      prisma.participantApproval.findMany({
        where: whereCondition,
        include: {
          participant: {
            select: {
              id: true,
              name: true,
              email: true,
              image: true,
              fisherProfile: {
                select: {
                  experience: true,
                  rating: true,
                  completedTrips: true,
                  reliability: true,
                  specialties: true
                }
              }
            }
          },
          trip: {
            select: {
              id: true,
              date: true,
              timeSlot: true,
              maxParticipants: true,
              minRequired: true,
              status: true,
              description: true,
              meetingPoint: true,
              captain: {
                select: {
                  id: true,
                  name: true,
                  email: true
                }
              },
              bookings: {
                where: { status: 'CONFIRMED' },
                select: { participants: true }
              }
            }
          }
        },
        orderBy: [
          { appliedAt: 'desc' },
          { status: 'asc' }
        ],
        skip: filters.offset,
        take: filters.limit
      }),
      prisma.participantApproval.count({
        where: whereCondition
      })
    ])

    console.log(`‚úÖ Found ${approvals.length} approvals (total: ${totalCount})`)

    // –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –æ —Ç–µ–∫—É—â–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–µ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤
    const enrichedApprovals = approvals.map(approval => {
      const currentParticipants = approval.trip.bookings.reduce(
        (sum, booking) => sum + booking.participants, 
        0
      )

      return {
        ...approval,
        trip: {
          ...approval.trip,
          currentParticipants,
          availableSpots: approval.trip.maxParticipants - currentParticipants
        }
      }
    })

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º –ø–æ —Å—Ç–∞—Ç—É—Å—É –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
    const stats = {
      total: totalCount,
      pending: approvals.filter(a => a.status === 'PENDING').length,
      approved: approvals.filter(a => a.status === 'APPROVED').length,
      rejected: approvals.filter(a => a.status === 'REJECTED').length
    }

    return NextResponse.json({
      success: true,
      data: {
        approvals: enrichedApprovals,
        stats,
        pagination: {
          total: totalCount,
          offset: filters.offset,
          limit: filters.limit,
          hasMore: filters.offset + filters.limit < totalCount
        }
      }
    })

  } catch (error) {
    console.error('‚ùå Error fetching approvals:', error)
    return NextResponse.json(
      { 
        success: false, 
        error: 'Internal server error',
        message: error instanceof Error ? error.message : 'Unknown error'
      },
      { status: 500 }
    )
  }
}