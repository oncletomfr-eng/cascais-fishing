/**
 * Export Download API Endpoint
 * Task 6.4: Data Export & Reporting System
 * 
 * Handles file downloads for completed exports
 */

import { NextRequest, NextResponse } from 'next/server';
import { auth } from '@/auth';

// Mock export history (same structure as in history route)
interface ExportHistory {
  id: string;
  userId: string;
  filename: string;
  format: 'csv' | 'pdf' | 'excel';
  dataType: string;
  fileSize: number;
  recordCount: number;
  exportedAt: Date;
  downloadUrl?: string;
  status: 'processing' | 'completed' | 'failed' | 'expired';
  error?: string;
  expiresAt?: Date;
}

// Mock file storage (in production, use cloud storage like AWS S3, Google Cloud Storage, etc.)
const mockFileStorage: Record<string, Buffer> = {};

// Helper function to generate mock file content
function generateMockFileContent(export_: ExportHistory): Buffer {
  const timestamp = export_.exportedAt.toISOString();
  
  switch (export_.format) {
    case 'csv':
      const csvContent = `Export ID,${export_.id}
Filename,${export_.filename}
Data Type,${export_.dataType}
Record Count,${export_.recordCount}
Exported At,${timestamp}
Status,${export_.status}

Sample Data:
Date,Amount,Status,Description
2024-01-01,100.00,completed,Sample payment 1
2024-01-02,250.50,completed,Sample payment 2
2024-01-03,75.25,completed,Sample payment 3
`;
      return Buffer.from(csvContent, 'utf-8');

    case 'excel':
      // In production, generate actual Excel file using libraries like xlsx or exceljs
      const excelContent = {
        metadata: {
          exportId: export_.id,
          filename: export_.filename,
          dataType: export_.dataType,
          recordCount: export_.recordCount,
          exportedAt: timestamp,
          status: export_.status
        },
        sheets: {
          summary: {
            title: 'Export Summary',
            data: [
              ['Export ID', export_.id],
              ['Filename', export_.filename],
              ['Data Type', export_.dataType],
              ['Record Count', export_.recordCount],
              ['File Size', `${(export_.fileSize / 1024).toFixed(2)} KB`],
              ['Exported At', timestamp],
              ['Status', export_.status]
            ]
          },
          data: {
            title: 'Sample Data',
            headers: ['Date', 'Amount', 'Status', 'Description'],
            rows: [
              ['2024-01-01', '100.00', 'completed', 'Sample payment 1'],
              ['2024-01-02', '250.50', 'completed', 'Sample payment 2'],
              ['2024-01-03', '75.25', 'completed', 'Sample payment 3']
            ]
          }
        }
      };
      return Buffer.from(JSON.stringify(excelContent, null, 2), 'utf-8');

    case 'pdf':
      // In production, generate actual PDF using libraries like puppeteer or PDFKit
      const pdfContent = {
        title: `${export_.dataType.toUpperCase()} Export Report`,
        metadata: {
          exportId: export_.id,
          filename: export_.filename,
          dataType: export_.dataType,
          recordCount: export_.recordCount,
          exportedAt: timestamp,
          status: export_.status
        },
        summary: {
          totalRecords: export_.recordCount,
          fileSize: `${(export_.fileSize / 1024).toFixed(2)} KB`,
          generatedAt: timestamp
        },
        sampleData: [
          { date: '2024-01-01', amount: '€100.00', status: 'completed', description: 'Sample payment 1' },
          { date: '2024-01-02', amount: '€250.50', status: 'completed', description: 'Sample payment 2' },
          { date: '2024-01-03', amount: '€75.25', status: 'completed', description: 'Sample payment 3' }
        ],
        footer: 'Generated by Cascais Fishing Export System'
      };
      return Buffer.from(JSON.stringify(pdfContent, null, 2), 'utf-8');

    default:
      return Buffer.from(`Export file for ${export_.filename}`, 'utf-8');
  }
}

// Mock export history data (should be shared with history route in production)
const exportHistory: ExportHistory[] = [
  {
    id: 'export_1',
    userId: 'user_1',
    filename: 'payments-export-2024-01-01.csv',
    format: 'csv',
    dataType: 'payments',
    fileSize: 1024 * 15,
    recordCount: 125,
    exportedAt: new Date('2024-01-01T10:30:00Z'),
    status: 'completed',
    downloadUrl: '/api/data-export/download/export_1',
    expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000)
  },
  {
    id: 'export_2',
    userId: 'user_1',
    filename: 'earnings-report-2024-01-02.pdf',
    format: 'pdf',
    dataType: 'earnings',
    fileSize: 1024 * 250,
    recordCount: 30,
    exportedAt: new Date('2024-01-02T14:15:00Z'),
    status: 'completed',
    downloadUrl: '/api/data-export/download/export_2',
    expiresAt: new Date(Date.now() + 5 * 24 * 60 * 60 * 1000)
  },
  {
    id: 'export_3',
    userId: 'user_1',
    filename: 'commissions-export-2024-01-03.xlsx',
    format: 'excel',
    dataType: 'commissions',
    fileSize: 1024 * 75,
    recordCount: 45,
    exportedAt: new Date('2024-01-03T09:45:00Z'),
    status: 'processing',
    expiresAt: new Date(Date.now() + 6 * 24 * 60 * 60 * 1000)
  }
];

// GET - Download export file
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Authentication check
    const session = await auth();
    if (!session?.user) {
      return NextResponse.json(
        { error: 'Authentication required' },
        { status: 401 }
      );
    }

    const userId = session.user.id;
    const exportId = params.id;

    // Find the export record
    const exportRecord = exportHistory.find(
      exp => exp.id === exportId && exp.userId === userId
    );

    if (!exportRecord) {
      return NextResponse.json(
        { error: 'Export not found' },
        { status: 404 }
      );
    }

    // Check if export is available for download
    if (exportRecord.status !== 'completed') {
      const statusMessages = {
        'processing': 'Export is still being processed',
        'failed': 'Export failed and cannot be downloaded',
        'expired': 'Export has expired and is no longer available'
      };
      
      return NextResponse.json(
        { 
          error: 'Export not available for download',
          reason: statusMessages[exportRecord.status as keyof typeof statusMessages] || 'Unknown status'
        },
        { status: 400 }
      );
    }

    // Check if export has expired
    if (exportRecord.expiresAt && exportRecord.expiresAt < new Date()) {
      // Update status to expired
      exportRecord.status = 'expired';
      exportRecord.downloadUrl = undefined;
      
      return NextResponse.json(
        { error: 'Export has expired and is no longer available' },
        { status: 410 } // Gone
      );
    }

    // Get or generate file content
    let fileBuffer = mockFileStorage[exportId];
    if (!fileBuffer) {
      // Generate mock file content
      fileBuffer = generateMockFileContent(exportRecord);
      mockFileStorage[exportId] = fileBuffer; // Cache for future downloads
    }

    // Determine content type based on format
    let contentType: string;
    let fileExtension: string;

    switch (exportRecord.format) {
      case 'csv':
        contentType = 'text/csv';
        fileExtension = 'csv';
        break;
      case 'excel':
        contentType = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet';
        fileExtension = 'xlsx';
        break;
      case 'pdf':
        contentType = 'application/pdf';
        fileExtension = 'pdf';
        break;
      default:
        contentType = 'application/octet-stream';
        fileExtension = 'dat';
    }

    // Ensure filename has correct extension
    const filename = exportRecord.filename.endsWith(`.${fileExtension}`)
      ? exportRecord.filename
      : `${exportRecord.filename}.${fileExtension}`;

    // Return the file
    return new NextResponse(fileBuffer, {
      status: 200,
      headers: {
        'Content-Type': contentType,
        'Content-Disposition': `attachment; filename="${filename}"`,
        'Content-Length': fileBuffer.length.toString(),
        'Cache-Control': 'private, max-age=3600', // Cache for 1 hour
        'X-Export-Id': exportRecord.id,
        'X-Export-Status': exportRecord.status,
        'X-Record-Count': exportRecord.recordCount.toString()
      }
    });

  } catch (error) {
    console.error('Download export API error:', error);
    return NextResponse.json(
      { error: 'Failed to download export' },
      { status: 500 }
    );
  }
}

// HEAD - Get file info without downloading
export async function HEAD(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  try {
    // Authentication check
    const session = await auth();
    if (!session?.user) {
      return new NextResponse(null, { status: 401 });
    }

    const userId = session.user.id;
    const exportId = params.id;

    // Find the export record
    const exportRecord = exportHistory.find(
      exp => exp.id === exportId && exp.userId === userId
    );

    if (!exportRecord) {
      return new NextResponse(null, { status: 404 });
    }

    if (exportRecord.status !== 'completed') {
      return new NextResponse(null, { status: 400 });
    }

    if (exportRecord.expiresAt && exportRecord.expiresAt < new Date()) {
      return new NextResponse(null, { status: 410 });
    }

    // Return headers without body
    return new NextResponse(null, {
      status: 200,
      headers: {
        'Content-Length': exportRecord.fileSize.toString(),
        'Content-Type': exportRecord.format === 'csv' ? 'text/csv' :
                       exportRecord.format === 'excel' ? 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' :
                       exportRecord.format === 'pdf' ? 'application/pdf' : 'application/octet-stream',
        'X-Export-Id': exportRecord.id,
        'X-Export-Status': exportRecord.status,
        'X-Record-Count': exportRecord.recordCount.toString(),
        'X-Expires-At': exportRecord.expiresAt?.toISOString() || ''
      }
    });

  } catch (error) {
    console.error('Export HEAD API error:', error);
    return new NextResponse(null, { status: 500 });
  }
}
